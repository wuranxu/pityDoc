---
nav:
title: 前置条件
order: 1-2
---

# 前置条件

  正如之前所说，前置条件与功能测试用例中的`前置条件`是一样的概念，举个例子: 当我们测试淘宝提交订单这个功能的时候，我们的前提是购物车里面有数据(这里就暂时不考虑余额)的事情，因为提交订单还不需要付款。

  所以我们的前置条件可以指定是: `添加商品到购物车`，如果算上登录淘宝，那么我们的一个case的执行逻辑大概是这样:

1. 用户登录淘宝
2. 用户添加n个商品到购物车
3. 用户提交订单

  我们针对提交订单还有多种场景，比如用户未登录，用户购物车无数据，用户购物车的宝贝已经被清空了等等。针对不同的`场景`，我们需要制造不同的前提（即前置条件）。

![](http://oss.pity.fun/picture/2022-2-27/1645952479566-image.png)

### 前置条件的顺序

  前置条件的顺序，在pity里面是`依次执行`的，大家也可以拖拽他们的顺序，控制整个流程。

### 前置条件的类型

  目前pity支持以下几种前置条件:
  
- [x] 测试用例

  当一个用例里面有很多复杂的部分，比如`登录，搜索商品，添加商品到购物车`，那我们可能就会将之包裹起来，组成一个用例，进而作为前置条件提供给下单这个用例。

- [x] sql语句

  我们知道，单纯校验接口的返回，往往不是太靠谱，我举个例子，开发的sql语句查询有误，会导致查询结果与预期有一些`偏差`。或者说开发的数据入库失败了，只存到了缓存里面，表面上看起来能够查询到这笔订单，实际上根本没入库，那都是很危险的事情。
  所以我是比较建议去做db校验的，也因此支持了sql操作。

- [x] python脚本

  总有些内容是不太`方便`做的，比如各个公司可能对于接口有一些安全策略，导致接口的请求体或者header需要加密/解密，所以这时候我们可以支持Python自定义语句，提高更好的扩展性。

- [x] redis

  redis就不说了，越来越流行，也有很多数据是直接存入redis的，所以对于redis的读取很有必要。

- [ ] http请求

  暂未支持，因为和用例有一定的重复度，所以可能后续也不会支持。

- [ ] 发送消息

  待支持。

  大体上就这么多种，以后会陆陆续续完善。
