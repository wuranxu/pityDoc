---
nav:
title: 接口依赖
order: 3
---

## 数据依赖

  我们都知道，在做`接口测试`的时候之所以有接口依赖，那大多是因为数据之间有依赖，所以我们依然可以用`全局变量`取值的方式，去解决数据依赖。

### 一个简单的例子

  假设我们需要测试`获取个人信息`的接口，那很显然，这是一个需要`登录`的接口。因为你不登录，我也不知道你取的是谁的`用户信息`。所以在执行接口测试之前，我们得先完成前置操作: `用户登录`。
  
  一般的系统，会有三种方式维持用户的登录状态: `token`，`session`, `cookie`。
  
  所以我们需要对自己待测的`系统`有所了解，以我自己写过的web服务为例子，大概流程如下:

![](http://oss.pity.fun/picture/2022-2-27/1645945203761-image.png)

  当header里面传有token信息，我们会校验它的可用性，包括`是否存在`，`是否过期`等。这一步通过以后，我们才会执行真实的接口逻辑。
  
  所以在上面这个例子里面，我们的`获取个人信息`接口，它依赖于`登录用例`，而实际上依赖的是登录用例返回的`token`数据。一旦我们能够自由编排case顺序:

  先登录=>获取到token=>将token传递给当前接口，那么这个问题就`迎刃而解`了。
  
### pity的数据传递

  所以我们引入了`前置条件`的概念，他们的执行结果都会被传递到`当前用例`，按照上面说的例子，前置条件是登录用例，返回的数据为:

```json
{
  "code": 0,
  "data": {
    "token": "一串私密的token"
  }
}
```

  那么我们会主动`设置`一个前置条件的返回值，假设为`login_result`，我们就可以拿到token数据了。

  与[全局变量](/数据依赖/全局变量介绍)保持一致, 采用**${变量名}**的方式获取其他变量。

  所以要注意变量的命名，别和全局变量/`其他变量名`冲突。我们取出token的方式:

```
${login_result.data.token}
```

  这样就能够拿到对应的数据了，我们可以写到headers里面，key填写`token`, value填写${login_result.data.token}, 静静等待pity帮助我们解决`数据依赖`的问题。
